**Simulado de Entrevista: Desenvolvedor Go Pleno/SÃªnior - Projeto de Upload para S3**

---

### ğŸŒŸ DescriÃ§Ã£o Geral do Projeto

O cÃ³digo em anÃ¡lise implementa um sistema concorrente para upload de arquivos de um diretÃ³rio local para um bucket na Amazon S3. Ele inclui:

- Leitura sequencial de arquivos em um diretÃ³rio (`./tmp`);
- Upload concorrente com limite de 100 uploads simultÃ¢neos;
- Controle de goroutines com `sync.WaitGroup`;
- Canal de erros com reprocessamento automÃ¡tico dos arquivos que falharem;
- Uso do AWS SDK para Go.

---

## ğŸ” Parte 1: CompreensÃ£o Geral do CÃ³digo

1. **Explique como funciona o controle de concorrÃªncia nesse programa.**
2. **Qual Ã© o papel do canal `uploadControl <- struct{}{}` antes de iniciar cada upload?**
3. **Por que usamos `WaitGroup` nesse contexto? O que poderia acontecer se omitÃ­ssemos?**
4. **O que `filepath.Base(fullPath)` estÃ¡ resolvendo nesse cÃ³digo?**

---

## ğŸš¨ Parte 2: ResiliÃªncia, Erros e Boas PrÃ¡ticas

5. **Explique como o reprocessamento de arquivos com erro estÃ¡ funcionando.**
6. **Existe risco de deadlock ou goroutines vazando? Como vocÃª garantiria o fechamento adequado dos canais?**
7. **A funÃ§Ã£o `uploadFile` chama `wg.Done()`, mas tambÃ©m Ã© chamada dentro de uma goroutine com outro `defer wg.Done()`. Isso estÃ¡ correto?**

---

## ğŸ“Š Parte 3: Design e Arquitetura

8. **Como vocÃª refatoraria esse projeto para algo mais testÃ¡vel e orientado a serviÃ§os?**
9. **Existe alguma vantagem/desvantagem em usar `ReadDir(1)` ao invÃ©s de `os.ReadDir()`?**
10. **Como esse cÃ³digo se comportaria com milhares de arquivos ou mÃºltiplos diretÃ³rios? Que ajustes seriam necessÃ¡rios?**

---

## ğŸ’¡ Parte 4: Conhecimento AvanÃ§ado

11. **Como vocÃª adicionaria suporte a backoff exponencial nas tentativas de reenvio?**
12. **Como permitir que os arquivos sejam salvos no S3 com caminho completo (subpastas) em vez de apenas o nome?**
13. **Esse cÃ³digo Ã© seguro para execuÃ§Ã£o em ambientes como Kubernetes? Por quÃª?**
14. **Onde vocÃª adicionaria mÃ©tricas Prometheus para monitorar performance e erros?**

---

## ğŸ”¬ Parte 5: Testabilidade

15. **Como vocÃª testaria a funÃ§Ã£o `uploadFile` de forma unitÃ¡ria?**
16. **Usar `os.Getenv` no `init()` Ã© uma boa prÃ¡tica em ambientes produtivos? O que vocÃª sugere?**

---

Este roteiro cobre os principais pontos que recrutadores ou tech leads podem explorar em uma entrevista de nÃ­vel pleno/sÃªnior envolvendo concorrÃªncia, AWS S3, boas prÃ¡ticas Go e design robusto de sistemas.

Proposta de nova estrutura clean, focada em testes, manutenibilidade e pronta para crescer. Abaixo estÃ¡ um esboÃ§o de estrutura com comentÃ¡rios explicativos:

bash
Copiar
Editar
/s3uploader                <- pasta raiz do projeto
â”œâ”€â”€ /cmd
â”‚   â””â”€â”€ /uploader          <- ponto de entrada
â”‚       â””â”€â”€ main.go        <- instancia o uploader e chama o Start()
â”‚
â”œâ”€â”€ /internal
â”‚   â””â”€â”€ /uploader          <- lÃ³gica principal de upload
â”‚       â”œâ”€â”€ uploader.go    <- interface e implementaÃ§Ã£o do uploader
â”‚       â””â”€â”€ s3.go          <- implementaÃ§Ã£o do S3Uploader
â”‚
â”œâ”€â”€ /pkg
â”‚   â””â”€â”€ /awsclient         <- abstraÃ§Ã£o do client AWS (opcional)
â”‚       â””â”€â”€ client.go      <- cria o *s3.S3
â”‚
â”œâ”€â”€ /tmp                  <- pasta com arquivos de exemplo (ignorÃ¡vel no versionamento)
â”‚
â”œâ”€â”€ go.mod
â””â”€â”€ go.sum
Arquivos principais
internal/uploader/uploader.go

package uploader

type Uploader interface {
	UploadFile(path string) error
}

internal/uploader/s3.go

package uploader

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/aws"
)

type S3Uploader struct {
	client *s3.S3
	bucket string
}

func NewS3Uploader(client *s3.S3, bucket string) *S3Uploader {
	return &S3Uploader{client: client, bucket: bucket}
}

func (u *S3Uploader) UploadFile(path string) error {
	filename := filepath.Base(path)

	file, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	_, err = u.client.PutObject(&s3.PutObjectInput{
		Bucket: aws.String(u.bucket),
		Key:    aws.String(filename),
		Body:   file,
	})
	return err
}

cmd/uploader/main.go

package main

import (
	"log"
	"os"
	"s3uploader/internal/uploader"
	"s3uploader/pkg/awsclient"
)

func main() {
	s3Client := awsclient.New() // cria cliente S3 com config
	u := uploader.NewS3Uploader(s3Client, os.Getenv("S3_BUCKET_NAME"))

	// Daqui vocÃª pode montar sua lÃ³gica de upload com goroutines, canais, etc
	err := u.UploadFile("./tmp/exemplo.txt")
	if err != nil {
		log.Fatalf("erro ao subir arquivo: %s", err)
	}
}


pkg/awsclient/client.go (opcional)

package awsclient

import (
	"os"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/s3"
)

func New() *s3.S3 {
	sess, err := session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
		Credentials: credentials.NewStaticCredentials(
			os.Getenv("AWS_ACCESS_KEY_ID"),
			os.Getenv("AWS_SECRET_ACCESS_KEY"),
			"",
		),
	})
	if err != nil {
		panic(err)
	}
	return s3.New(sess)
}
